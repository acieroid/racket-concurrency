#lang racket
(require "actors.rkt")

(define N 9)
(define B 3)
(define W 3)

(define (build-vector n f)
  (letrec ((v (make-vector n #f))
           (loop (lambda (i)
                   (if (< i n)
                       (begin
                         (vector-set! v i (f i))
                         (loop (+ i 1)))
                       v))))
    (loop 0)))
(define (for-each f l)
  (if (null? l)
      #t
      (if (pair? l)
          (begin (f (car l)) (for-each f (cdr l)))
          (error "Cannot for-each over a non-list"))))

(define (generate-graph)
  (let ((local-data (build-vector N (lambda (i) (make-vector N 0)))))
    (letrec ((loopi (lambda (i)
                      (if (= i N)
                          #t
                          (letrec ((loopj (lambda (j)
                                            (if (= j N)
                                                #t
                                                (let ((r (+ 1 (random W))))
                                                  (vector-set! (vector-ref local-data i) j r)
                                                  (vector-set! (vector-ref local-data j) i r)
                                                  (loopj (+ j 1)))))))
                            (loopj (+ i 1))
                            (loopi (+ i 1)))))))
      (loopi 0)
      local-data)))

(define graph-data (generate-graph))

(define (get-block src id)
  (let* ((local-data (build-vector B (lambda (i) (make-vector B 0))))
         (num-blocks-per-dim (inexact->exact (floor (/ N B))))
         (global-start-row (* (inexact->exact (floor (/ id num-blocks-per-dim))) B))
         (global-start-col (* (modulo id num-blocks-per-dim) B)))
    (letrec ((loopi (lambda (i)
                      (if (= i B)
                          #t
                          (letrec ((loopj (lambda (j)
                                            (if (= j B)
                                                #t
                                                (begin
                                                  (vector-set! (vector-ref local-data i) j
                                                               (vector-ref (vector-ref src (+ i global-start-row))
                                                                           (+ j global-start-col)))
                                                  (loopj (+ j 1)))))))
                            (loopj 0)
                            (loopi (+ i 1)))))))
      (loopi 0)
      local-data)))

(define (apsp-actor id block-size graph-size init-graph-data)
  (let* ((num-blocks-in-single-dim (inexact->exact (floor (/ graph-size block-size))))
         (num-neighbors (* 2 (- num-blocks-in-single-dim 1)))
         (row-offset (* (inexact->exact (floor (/ id num-blocks-in-single-dim))) block-size))
         (col-offset (* (modulo id num-blocks-in-single-dim) block-size)))
    (letrec ((actor (a/actor "apsp-actor" (neighbors k neighbor-data-per-iteration received-neighbors current-iter-data)
                        (result (src-k src-id init-data)
                                (if (not received-neighbors) (error "not received neighbors yet") #f)
                                ;; storeIterationData
                                ;; neighbor-data-per-iteration -> (cons (cons src-id init-data) neighbor-...)
                                (if (= (length neighbor-data-per-iteration) num-neighbors)
                                    (let ((k2 (+ k 1)))
                                      ;; performComputation()
                                      (let ((current-iter-data2 (build-vector block-size (lambda (i) (make-vector block-size 0))))
                                            (element-at (lambda (row col src-iter)
                                                          (let* ((dest-block-id (+ (* (inexact->exact (floor (/ row block-size))) num-blocks-in-single-dim)
                                                                                   (inexact->exact (floor (/ col block-size)))))
                                                                 (local-row (modulo row block-size))
                                                                 (local-col (modulo col block-size)))
                                                            (if (= dest-block-id id)
                                                                (vector-ref (vector-ref current-iter-data local-row) local-col)
                                                                (let ((block-data (cdr (assoc dest-block-id neighbor-data-per-iteration))))
                                                                  (vector-ref (vector-ref block-data local-row) local-col)))))))
                                        (letrec ((loopi (lambda (i)
                                                          (if (= i block-size)
                                                              #t
                                                              (letrec ((loopj (lambda (j)
                                                                                (if (= j block-size)
                                                                                    #t
                                                                                    (let* ((gi (+ row-offset i))
                                                                                           (gj (+ col-offset j))
                                                                                           (el1 (element-at gi k2 (- k2 1)))
                                                                                           (el2 (element-at k2 gj (- k2 1)))
                                                                                           (new-iter-data (+ el1 el2)))
                                                                                      (vector-set! (vector-ref current-iter-data2 i) j
                                                                                                   (min (vector-ref (vector-ref current-iter-data i) j)
                                                                                                        new-iter-data))
                                                                                      (loopj (+ j 1)))))))
                                                                (loopj 0)
                                                                (loopi (+ i 1)))))))
                                          (loopi 0))
                                        ;; notifyNeighbors()
                                        (for-each (lambda (loop-neighbor) (a/send loop-neighbor result k2 id current-iter-data2)) neighbors)
                                        ;; neighborDataPerIteration.clear()
                                        (printf "k2: ~a, graph-size - 1 = ~a~n" k2 (- graph-size 1))
                                        (if (= k2 (- graph-size 1))
                                            (a/terminate)
                                            (a/become actor neighbors k2 '() received-neighbors current-iter-data2))))
                                    (a/become actor neighbors k (cons (cons src-id init-data) neighbor-data-per-iteration)
                                              received-neighbors current-iter-data)))
                        (initial ()
                                 (for-each (lambda (loop-neighbor) (a/send loop-neighbor result k id current-iter-data)) neighbors)
                                 (a/become actor neighbors k neighbor-data-per-iteration received-neighbors current-iter-data))
                        (neighbor (new-neighbors)
                                  (a/become actor new-neighbors k neighbor-data-per-iteration #t current-iter-data)))))
      (a/create actor '() -1 '() #f (get-block init-graph-data id)))))

(define num-nodes N)
(define block-size B)
(define num-blocks-in-single-dim (inexact->exact (floor (/ num-nodes block-size))))
(define block-actors (build-vector num-blocks-in-single-dim
                                   (lambda (i)
                                     (build-vector num-blocks-in-single-dim
                                                   (lambda (j)
                                                     (let ((id (+ (* i num-blocks-in-single-dim) j)))
                                                       (apsp-actor id block-size num-nodes graph-data)))))))
(letrec ((loopi (lambda (bi)
                  (if (= bi num-blocks-in-single-dim)
                      #t
                      (letrec ((loopj (lambda (bj)
                                        (if (= bj num-blocks-in-single-dim)
                                            #t
                                            (letrec ((neighbors-loop1 (lambda (r acc)
                                                                        (if (= r num-blocks-in-single-dim)
                                                                            acc
                                                                            (if (= r bi)
                                                                                (neighbors-loop2 (+ r 1) acc)
                                                                                (neighbors-loop2 (+ r 1) (cons (vector-ref (vector-ref block-actors r) bj) acc))))))
                                                     (neighbors-loop2 (lambda (c acc)
                                                                        (if (= c num-blocks-in-single-dim)
                                                                            acc
                                                                            (if (= c bj)
                                                                                (neighbors-loop2 (+ c 1) acc)
                                                                                (neighbors-loop2 (+ c 1) (cons (vector-ref (vector-ref block-actors bi) c) acc)))))))
                                              (let ((neighbors (reverse (neighbors-loop2 0 (neighbors-loop1 0 '())))))
                                                (a/send (vector-ref (vector-ref block-actors bi) bj) neighbor neighbors))
                                              (loopj (+ bj 1)))))))
                        (loopj 0)
                        (loopi (+ bi 1)))))))
  (loopi 0))

(letrec ((loopi (lambda (bi)
                  (if (= bi num-blocks-in-single-dim)
                      #t
                      (letrec ((loopj (lambda (bj)
                                        (if (= bj num-blocks-in-single-dim)
                                            #t
                                            (begin
                                              (a/send (vector-ref (vector-ref block-actors bi) bj) initial)
                                              (loopj (+ bj 1)))))))
                        (loopj 0)
                        (loopi (+ bi 1)))))))
  (loopi 0))
(a/wait)
