#lang racket
(provide a/actor)
(provide a/send)
(provide a/self)
(provide a/become)
(provide a/terminate)
(provide a/create)
(provide a/log)
(provide a/recorded-actors)
(provide a/recorded)
(provide a/wait)
(provide int-top)

(define id -1)

;(provide actor-names)
;(provide thread-names)

(define actor-names (make-hash)) ;; map actor (proc) -> name
(define thread-names (make-hash)) ;; map thread -> name
(define (abstract x)
  (cond ((integer? x) '{Int})
        ((string? x) '{Str})
        ((symbol? x) '{Sym})
        ((thread? x) (if (hash-has-key? thread-names x) (string->symbol (hash-ref thread-names x)) "???"))
        ((procedure? x) (if (hash-has-key? actor-names x) (string->symbol (hash-ref actor-names x)) x))
        ((list? x) (if (empty? x) '() "\"#<list>\""))
        ((vector? x) "\"#<vector>\"")
        (else x)))
(define recorded (make-hash)) ;; map thread - become/beh/args, create/beh/args, received/tag/args
(define record-thread (thread (lambda ()
                                (let loop ()
                                  (let* ((recv (thread-receive))
                                         (prev (if (hash-has-key? recorded (car recv)) (hash-ref recorded (car recv)) (set))))
                                    (hash-set! recorded (car recv) (set-add prev (cdr recv))))
                                  (loop)))))
(define (a/recorded-actors)
  (hash-keys recorded))
(define (a/recorded actor)
  (list->set (set-map (hash-ref recorded actor) (lambda (x) (map force x)))))
(define (int-top) (+ 2 (random 10)))
(define (display-recorded)
  (map (lambda (k)
         (printf "~a~n" (list k (set->list (a/recorded k)))))
       (a/recorded-actors)))
(define log-thread (thread (lambda ()
                             (let loop ()
                               (let ((evt (thread-receive-evt)))
                                 (if (sync/timeout 0.5 evt)
                                     (begin
                                       (printf "~a" (thread-receive))
                                       (loop))
                                     (begin
                                       (printf "done; exiting~n")
                                       (display-recorded)
                                       (exit))))))))
(define-syntax a/self
  (syntax-id-rules ()
    [self (current-thread)]))
(define-syntax a/self-name
  (syntax-id-rules ()
    [self (hash-ref thread-names a/self)]))
(define-syntax-rule (a/send act msg arg1 ...)
  (begin
    (log "[~a] send message ~a to ~a (running? ~a) ~n" a/self-name 'msg (hash-ref thread-names act) (thread-running? act))
    (thread-send act (cons 'msg (list arg1 ...)))))
(define-syntax bind-lists
  (syntax-rules ()
    [(bind-lists (x y ...) l body ...)
     (let ((x (car l)))
       (bind-lists (y ...) (rest l) body ...))]
    [(bind-lists () l body ...)
     (begin body ...)]))
(define-syntax-rule (a/actor name (state ...) (msg (arg ...) body ...) ...)
  (let ((act (lambda (m state ...)
    (log "send to record-thread ~a ~a~n" (thread-running? record-thread) (thread-dead? record-thread))
    (thread-send record-thread (list a/self-name 'received (car m) (delay (map abstract (cdr m)))))
    ;(log "actor ~a received ~a~n" name m)
    (case (car m)
      ((msg) (bind-lists (arg ...) (cdr m)
                         (log "[~a] processing message ~a~a~n" name (car m) (map abstract (cdr m)))
                         body ...))
      ...
      (else
       (log "[~a] unknown message receive: ~a~n" name m))))))
    (hash-set! actor-names act name)
    act))
(define-syntax-rule (a/become act v1 ...)
  (begin
    (log "[~a] becoming ~a with ~a~n" a/self-name (hash-ref actor-names act) (map abstract (list v1 ...)))
    (thread-send record-thread (list a/self-name 'become (hash-ref actor-names act) (delay (map abstract (list v1 ...)))))
    (act (thread-receive) v1 ...)))
(define-syntax-rule (log fmt v ...)
  (thread-send log-thread (format fmt v ...)))
(define-syntax-rule (a/log v ...)
  (log v ...))
(define-syntax-rule (a/terminate)
  (begin
    (log "[~a] terminating~n" a/self-name)
    (kill-thread (current-thread))))
(define-syntax-rule (a/create act v1 ...)
  (let ((parent-name a/self-name)
        (values (list v1 ...)))
    (let ((t (thread (lambda ()
              (hash-set! thread-names a/self (hash-ref actor-names act))
              ;; TODO: replace map abstract by just list, apply abstract when reading recorded values instead
              (thread-send record-thread (list parent-name 'create (hash-ref actor-names act) (delay (map abstract values))))
              (log "[~a] creating ~a with ~a ~n" parent-name (hash-ref actor-names act) (map abstract values))
              (apply act (cons (thread-receive) values))))))
      (sleep 0.1)
      t)))
(define (a/wait)
  (sleep 1)
  (a/wait))
(hash-set! thread-names a/self "main")
