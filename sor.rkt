#lang racket
(require "actors.rkt")

(define data-sizes
  (list 2 8 10 12 15 20 25 30 35 40 20 80 100 120 150 200 250 300 350 400))
(define jacobi-num-iter 10)
(define omega 1.25)
(define N 0)

(define (perform-computation theta)
  (let* ((sint (sin theta))
         (res (* sint sint)))
    (if (<= res 0)
        (error "unrealistic res value")
        res)))
(define (random-matrix M N)
  (build-vector M (lambda (i) (build-vector N (lambda (j) (* 0.000001 (exact->inexact (/ (random 100) 100))))))))
(define A
  (let ((data-size (list-ref data-sizes N)))
    (random-matrix data-size data-size)))

(define (guard n v)
  (if (vector? v) v
      (error (format "not a vector ~a" n))))

(define (sor-runner-actor n)
  (let* ((s (list-ref data-sizes n))
         (part (inexact->exact (floor (/ s 2))))
         (sor-actors (make-vector (* s (+ part 1)) #f)))
    (define (boot self)
      (let ((my-border (make-vector s #f))
            (partial-matrix (build-vector s (lambda (i) (make-vector (- s part) 0))))) ;; randoms is A
        (letrec ((loop1i (lambda (i)
                           (if (= i s) #t
                               (let ((c (modulo i 2)))
                                 (letrec ((loop1j (lambda (j)
                                                    (if (= j part) #t
                                                        (let ((pos (+ (* i (+ part 1)) j)))
                                                          (set! c (- 1 c))
                                                          (vector-set! sor-actors pos (sor-actor pos (vector-ref (guard 1 (vector-ref (guard 2 A) i)) j)
                                                                                                 c s (+ part 1) omega self #f))
                                                          (if (= j (- part 1))
                                                              (vector-set! my-border i (vector-ref (guard 3 sor-actors) pos))
                                                              #f)
                                                          (loop1j (+ j 1)))))))
                                   (loop1j 0)
                                   (loop1i (+ i 1)))))))
                 (loop2i (lambda (i)
                           (if (= i s) #t
                               (letrec ((loop2j (lambda (j)
                                                  (if (= j (- s part)) #t
                                                      (begin
                                                        (vector-set! (vector-ref (guard 5 partial-matrix) i) j (vector-ref (guard 5 (vector-ref (guard 6 A) i)) (+ j part)))
                                                        (loop2j (+ j 1)))))))
                                 (loop2j 0)
                                 (loop2i (+ i 1)))))))
          (loop1i 0)
          (loop2i 0)
          (a/send (sor-peer s part partial-matrix my-border self) boot))))
    (letrec ((actor
              (a/actor "sor-runner" (g-total returned total-msg-rcv expecting-boot)
                       (boot ()
                             (boot a/self)
                             (a/become actor g-total returned total-msg-rcv #f))
                       (result (mx my mv msg-rcv)
                               (if expecting-boot (error "not booted yet!") #f)
                               (if (= (+ returned 1) (+ (* s part) 1))
                                   (a/terminate)
                                   (a/become actor (+ g-total mv) (+ returned 1) (+ total-msg-rcv msg-rcv) expecting-boot)))
                       (border (mborder)
                               (if expecting-boot (error "not booted yet!") #f)
                               (letrec ((loop1i (lambda (i)
                                                  (if (= i s) #t
                                                      (begin
                                                        (vector-set! sor-actors (- (* (+ i 1) (+ part 1)) 1) (vector-ref (guard 7 mborder) i))
                                                        (loop1i (+ i 1))))))
                                        (loop2i (lambda (i)
                                                  (if (= i s)
                                                      #t
                                                      (letrec ((loop2j (lambda (j)
                                                                         (if (= j part)
                                                                             #t
                                                                             (let ((pos (+ (* i (+ part 1)) j)))
                                                                               (a/send (vector-ref (guard 8 sor-actors) pos) start jacobi-num-iter sor-actors)
                                                                               (loop2j (+ j 1)))))))
                                                        (loop2j 0)
                                                        (loop2i (+ i 1)))))))
                                 (loop1i 0)
                                 (loop2i 0))
                               (a/become actor g-total returned total-msg-rcv expecting-boot)))))
      (a/create actor 0.0 0 0 #t))))

(define (sor-actor pos value color nx ny omega sor-source peer)
  (define (cal-pos x1 y1)
    (+ (* x1 ny) y1))
  (let* ((x (inexact->exact (floor (/ pos ny))))
         (y (modulo pos ny))
         (omega-over-four (* 0.25 omega))
         (one-minus-omega (- 1.0 omega))
         (neighbors
          (if (and (> x 0) (< x (- nx 1)) (> y 0) (< y (- ny 1)))
              (list (cal-pos x (+ y 1)) (cal-pos (+ x 1) y) (cal-pos x (- y 1)) (cal-pos (- x 1) y))
              (if (and (or (= x 0) (= x (- nx 1))) (or (= y 0) (= y (- ny 1))))
                  (list (if (= x 0) (cal-pos (+ x 1) y) (cal-pos (- x 1) y))
                        (if (= y 0) (cal-pos x (+ y 1)) (cal-pos x (- y 1))))
                  (if (or (or (= x 0) (= x (- nx 1))) (or (= y 0) (= y (- ny 1))))
                      (if (or (= x 0) (= x (- nx 1)))
                          (list (if (= x 0) (cal-pos (+ x 1) y) (cal-pos (- x 1) y))
                                (cal-pos x (+ y 1)) (cal-pos x (- y 1)))
                          (list (if (= y 0) (cal-pos x (+ y 1)) (cal-pos x (- y 1)))
                                (cal-pos (+ x 1) y) (cal-pos (- x 1) y)))
                      '())))))
    (letrec ((actor (a/actor "sor-actor" (value iter max-iter msg-rcv sor-actors received-vals sum expecting-start pending-messages)
                             (start (mi mactors)
                                    (if (= color 1)
                                        (for-each (lambda (loop-neigh-index)
                                                    (a/send (vector-ref (guard 15 mactors) loop-neigh-index) value value))
                                                  neighbors)
                                        #f)
                                    (for-each (lambda (v) (a/send a/self sor-value v)) pending-messages)
                                    (a/become actor value (if (= color 1) (+ iter 1) iter) mi (if (= color 1) (+ msg-rcv 1) msg-rcv)
                                              mactors received-vals sum #f '()))
                             (sor-value (v)
                                        (if expecting-start
                                            (a/become actor value iter max-iter msg-rcv sor-actors received-vals sum expecting-start (cons v pending-messages))
                                            (if (< iter max-iter)
                                                (if (= (+ received-vals 1) (length neighbors))
                                                    (begin
                                                      (for-each (lambda (loop-neigh-index) (a/send (vector-ref (guard 9 sor-actors) loop-neigh-index) value value)) neighbors)
                                                      (if (= (+ iter 1) max-iter)
                                                          (begin
                                                            (a/send sor-source result x y value msg-rcv)
                                                            (a/terminate))
                                                          (a/become actor (+ (* omega-over-four sum) (* one-minus-omega value))
                                                                    (+ iter 1) max-iter (+ msg-rcv 1) sor-actors (+ received-vals 1) (+ sum v) expecting-start pending-messages)))
                                                    (a/become actor value iter max-iter (+ msg-rcv 1) sor-actors (+ received-vals 1) (+ sum v) expecting-start pending-messages))
                                                (a/terminate)
                                                ))))))
      (a/create actor value 0 0 0 #f 0 0.0 #t '()))))

(define (sor-peer s part-start matrix-part border sor-source)
  (let ((sor-actors (make-vector (* s (+ (- s part-start) 1)) #f)))
    (define (boot self)
      (let ((my-border (make-vector s #f)))
        (letrec ((loop1 (lambda (i)
                          (if (= i s) #t
                              (begin
                                (vector-set! sor-actors (* i (+ (- s part-start) 1)) (vector-ref (guard 10 border) i))
                                (loop1 (+ i 1))))))
                 (loop2i (lambda (i)
                           (if (= i s) #t
                               (let ((c (modulo (+ i part-start) 2)))
                                 (letrec ((loop2j (lambda (j)
                                                    (if (= j (+ (- s part-start) 1)) #t
                                                        (let ((pos (+ (* i (+ (- s part-start) 1)) j)))
                                                          (set! c (- 1 c))
                                                          (vector-set! sor-actors pos
                                                                       (sor-actor pos (vector-ref (guard 11 (vector-ref (guard 12 matrix-part) i)) (- j 1))
                                                                                  c s (+ (- s part-start) 1)
                                                                                  omega self #t))
                                                          (if (= j 1) (vector-set! my-border i (vector-ref (guard 102 sor-actors) pos)) #f)
                                                          (loop2j (+ j 1)))))))
                                   (loop2j 1)
                                   (loop2i (+ i 1)))))))
                 (loop3i (lambda (i)
                           (if (= i s) #t
                               (letrec ((loop3j (lambda (j)
                                                  (if (= j (+ (- s part-start) 1)) #t
                                                      (let ((pos (+ (* i (+ (- s part-start) 1)) j)))
                                                        (a/send (vector-ref (guard 13 sor-actors) pos) start jacobi-num-iter sor-actors)
                                                        (loop3j (+ j 1)))))))
                                 (loop3j 1)
                                 (loop3i (+ i 1)))))))
          (loop1 0)
          (loop2i 0)
          (a/send sor-source border my-border)
          (loop3i 0))))
    (letrec ((actor (a/actor "sor-peer" (g-total returned total-msg-rcv expecting-boot)
                             (boot ()
                                   (boot a/self)
                                   (a/become g-total returned total-msg-rcv #f))
                             (result (mx my mv msg-rcv)
                                     (if expecting-boot (error "not booted yet") #f)
                                     (if (= (+ returned 1) (* s (- s part-start)))
                                         (begin (a/send sor-source result -1 -1 g-total total-msg-rcv)
                                                (a/terminate))
                                         (a/become actor (+ g-total mv) (+ returned 1) (+ total-msg-rcv msg-rcv) expecting-boot))))))
      (a/create actor 0.0 0 0 #t))))

(define sor-runner (sor-runner-actor N))
(a/send sor-runner boot)
(a/wait)
