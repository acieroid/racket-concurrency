#lang racket
(require "actors.rkt")

(define N (int-top))
(define M (int-top))
(define S (int-top))


(define value-data-adapter-actor
  (a/actor "value-data-adapter-actor" (order-id next-actor)
           (value (v)
                  (a/send next-actor data order-id v)
                  (a/become value-data-adapter-actor order-id next-actor))
           (data (id v)
                 (a/send next-actor data id v)
                 (a/become value-data-adapter-actor order-id next-actor))
           (exit ()
                 (a/send next-actor exit)
                 (a/terminate))))
(define data-value-adapter-actor
  (a/actor "data-value-adapter-actor" (next-actor)
           (value (v)
                  (a/send next-actor value v)
                  (a/become data-value-adapter-actor next-actor))
           (data (id v)
                 (a/send next-actor value v)
                 (a/become data-value-adapter-actor next-actor))
           (exit ()
                 (a/send next-actor exit)
                 (a/terminate))))

(define round-robin-splitter-actor
  ;; receivers is a list of actors, receiver-index and current-run start at 0
  (a/actor "round-robin-splitter-actor" (len receivers receiver-index current-run)
           (value (v)
                  (letrec ((loop-send-rcv-idx (lambda (i l)
                                                (if (= i receiver-index)
                                                    (a/send (car l) value v)
                                                    (loop-send-rcv-idx (+ i 1) (cdr l))))))
                    (loop-send-rcv-idx 0 receivers)
                    (if (= (+ current-run 1) len)
                        (a/become round-robin-splitter-actor len receivers (modulo (+ receiver-index 1) (length receivers)) 0)
                        (a/become round-robin-splitter-actor len receivers receiver-index (+ current-run 1)))))
           (exit () (letrec ((loop-exit-rr (lambda (acts)
                                             (if (empty? acts)
                                                 (a/terminate)
                                                 (begin
                                                   (a/send (car acts) exit)
                                                   (loop-exit-rr (cdr acts)))))))
                      (loop-exit-rr receivers)))))
(define round-robin-joiner-actor
  ;; received-data is a vector of size num-joiners, initialized to empty lists, forward-index, current-run and exits-received start at 0
  (a/actor "round-robin-joiner-actor" (len num-joiners next-actor received-data forward-index current-run exits-received)
           (data (order-id v)
                 (vector-set! received-data order-id (append (vector-ref received-data order-id) (cons v '())))
                 (let ((to-forward (vector-ref received-data forward-index)))
                   (if (empty? to-forward)
                       (a/become round-robin-joiner-actor len num-joiners next-actor received-data forward-index current-run exits-received)
                       (let ((current-run2 (if (= (+ 1 current-run) len) 0 (+ current-run 1)))
                             (forward-index2 (if (= (+ 1 current-run) len) (modulo (+ forward-index 1) num-joiners) forward-index)))
                         (a/send next-actor value v)
                         (a/become round-robin-joiner-actor len num-joiners next-actor received-data forward-index2 current-run2 exits-received)))))
           (exit ()
                 (if (= (+ exits-received 1) num-joiners)
                     (begin
                       (a/send next-actor exit)
                       (a/terminate))
                     (a/become round-robin-joiner-actor len num-joiners next-actor received-data forward-index current-run (+ exits-received 1))))))
(define compare-exchange-actor
  ;; k1: 0, value-available: #f
  (a/actor "compare-exchange-actor" (order-id sort-direction next-actor k1 value-available)
           (value (v)
                  (if (not value-available)
                      (a/become compare-exchange-actor order-id sort-direction next-actor v value-available)
                      (let* ((k2 v)
                             (mink (min k1 k2))
                             (maxk (max k1 k2)))
                        (if sort-direction
                            ;; up sort
                            (begin
                              (a/send next-actor data order-id mink)
                              (a/send next-actor data order-id maxk))
                            ;; down sort
                            (begin
                              (a/send next-actor data order-id maxk)
                              (a/send next-actor data order-id mink)))
                        (a/become compare-exchange-actor order-id sort-direction next-actor k1 #f))))
           (exit ()
                 (a/send next-actor exit)
                 (a/terminate))))
(define (create-partition-bitonic-sequence-actor order-id len sort-dir next-actor)
  (letrec ((halflen (inexact->exact (floor (/ len 2))))
           (forward-actor (a/create value-data-adapter-actor order-id next-actor))
           (joiner-actor (a/create round-robin-joiner-actor 1 halflen forward-actor))
           (worker-actors (letrec ((loop-worker-seq (lambda (i acc)
                                                      (if (< i halflen)
                                                          (loop-worker-seq (+ i 1) (cons (a/create compare-exchange-actor i sort-dir joiner-actor 0 #f) acc))
                                                          acc))))
                            (loop-worker-seq 0 '())))
           (splitter-actor (a/create round-robin-splitter-actor 1 worker-actors 0 0))
           (partition-bitonic-sequence-actor
            (a/actor "partition-bitonic-sequence-actor" ()
                     (value (v)
                            (a/send splitter-actor value v)
                            (a/become partition-bitonic-sequence-actor))
                     (exit ()
                           (a/send splitter-actor exit)
                           (a/terminate)))))
    (a/create partition-bitonic-sequence-actor)))

(define (create-step-of-merge-actor order-id len num-seq-partitions direction-counter next-actor)
  (letrec ((forward-actor (a/create data-value-adapter-actor next-actor))
           (joiner-actor (a/create round-robin-joiner-actor len num-seq-partitions forward-actor (make-vector num-seq-partitions '()) 0 0 0))
           (worker-actors (letrec ((loop-worker-step-of-merge (lambda (i acc)
                                                                (if (< i num-seq-partitions)
                                                                    (loop-worker-step-of-merge (+ i 1)
                                                                                               (let ((current-direction (= 0 (modulo (inexact->exact (floor (/ i direction-counter))) 2))))
                                                                                                 (cons
                                                                                                  (if (> len 2)
                                                                                                      (create-partition-bitonic-sequence-actor i len current-direction joiner-actor)
                                                                                                      (a/create compare-exchange-actor i current-direction joiner-actor 0 #f))
                                                                                                  acc)))
                                                                    acc))))
                            (loop-worker-step-of-merge 0 '())))
           (splitter-actor (a/create round-robin-splitter-actor len worker-actors 0 0))
           (step-of-merge-actor
            (a/actor "step-of-merge-actor" ()
                     (value (v)
                            (a/send splitter-actor value v)
                            (a/become step-of-merge-actor))
                     (exit ()
                           (a/send splitter-actor exit)
                           (a/terminate)))))
    (a/create step-of-merge-actor)))
(define (create-step-of-last-merge-actor len num-seq-partitions sort-direction next-actor)
  (letrec ((joiner-actor (a/create round-robin-joiner-actor len num-seq-partitions (make-vector num-seq-partitions '()) 0 0 0))
           (worker-actors (letrec ((loop-last-merge (lambda (i acc)
                                                      (if (< i num-seq-partitions)
                                                          (cons
                                                           (if (> len 2)
                                                               (create-partition-bitonic-sequence-actor i len sort-direction joiner-actor)
                                                               (a/create compare-exchange-actor i sort-direction joiner-actor 0 #f))
                                                           acc)
                                                          acc))))
                            (loop-last-merge 0 '())))
           (splitter-actor (a/create round-robin-splitter-actor len worker-actors 0 0))
           (step-of-last-merge-actor
            (a/actor "step-of-last-merge-actor" ()
                     (value (v)
                            (a/send splitter-actor value v)
                            (a/become step-of-last-merge-actor))
                     (exit ()
                           (a/send splitter-actor exit)
                           (a/terminate)))))
    (a/create step-of-last-merge-actor)))
(define (create-merge-stage-actor p n next-actor)
  (letrec ((forward-actor (letrec ((loop-forward-merge-stage (lambda (i loop-actor)
                                                               (if (>= i 1)
                                                                   (let* ((l (inexact->exact (floor (/ p i))))
                                                                          (num-seq-partitions (* i (inexact->exact (floor (/ n p)))))
                                                                          (direction-counter i))
                                                                     (loop-forward-merge-stage (inexact->exact (floor (/ i 2)))
                                                                                               (create-step-of-merge-actor i l num-seq-partitions direction-counter loop-actor)))
                                                                   loop-actor))))
                            (loop-forward-merge-stage (inexact->exact (floor (/ p 2))) next-actor)))
           (merge-stage-actor
            (a/actor "merge-stage-actor" ()
                     (value (v)
                            (a/send forward-actor value v)
                            (a/become merge-stage-actor))
                     (exit ()
                           (a/terminate)))))
    (a/create merge-stage-actor)))
(define (create-last-merge-stage-actor n sort-direction next-actor)
  (letrec ((forward-actor (letrec ((loop-forward-last-merge-stage (lambda (i loop-actor)
                                                                    (if (>= i 1)
                                                                        (let ((l (inexact->exact (floor (/ n i))))
                                                                              (num-seq-partitions i))
                                                                          (loop-forward-last-merge-stage
                                                                           (inexact->exact (floor (/ i 2)))
                                                                           (create-step-of-last-merge-actor l num-seq-partitions sort-direction loop-actor)))
                                                                        loop-actor))))
                            (loop-forward-last-merge-stage (inexact->exact (floor (/ n 2))) next-actor)))
           (last-merge-stage-actor
            (a/actor "last-merge-stage-actor" ()
                     (value (v)
                            (a/send forward-actor value v)
                            (a/terminate))
                     (exit ()
                           (a/send forward-actor exit)
                           (a/terminate)))))
    (a/create last-merge-stage-actor)))
(define (create-bitonic-sort-kernel-actor n sort-direction next-actor)
  (letrec ((forward-actor (letrec ((loop-actor (create-last-merge-stage-actor n sort-direction next-actor))
                                   (loop-forward (lambda (i lp-actor)
                                                   (if (>= i 2)
                                                       (let* ((temp-actor (create-merge-stage-actor i n lp-actor)))
                                                         (loop-forward (inexact->exact (floor (/ i 2))) temp-actor))
                                                       lp-actor))))
                            (loop-forward (inexact->exact (floor (/ N 2))) next-actor)))
           (bitonic-sort-kernel-actor
            (a/actor "bitonic-sort-kernel-actor" ()
                     (value (v)
                            (a/send forward-actor value v)
                            (a/become bitonic-sort-kernel-actor))
                     (exit ()
                           (a/send forward-actor exit)
                           (a/terminate)))))
    (a/create bitonic-sort-kernel-actor)))

(define int-source-actor
  (a/actor "int-source-actor" (next-actor)
           (start ()
                  (letrec ((loop-source (lambda (i)
                                          (if (< i N)
                                              (let ((candidate (modulo (abs (random 100)) M)))
                                                (a/send next-actor value candidate)
                                                (loop-source (+ i 1)))
                                              #f))))
                    (loop-source 0)
                    (a/send next-actor exit)
                    (a/terminate)))))
(define validation-actor
  ;; all values initially set to 0, except error values set to -1
  (a/actor "validation-actor" (sum-so-far values-so-far prev-value error-value-1 error-value-2)
           (value (v)
                  (let ((values-so-far2 (+ values-so-far 1))
                        (error-value-12 (if (and (< v prev-value) (< error-value-1 0)) v error-value-1))
                        (error-value-22 (if (and (< v prev-value) (< error-value-1 0)) (- values-so-far 1) error-value-2))
                        (prev-value2 v)
                        (sum-so-far2 (+ sum-so-far v)))
                    (a/become validation-actor sum-so-far2 values-so-far2 prev-value2 error-value-12 error-value-22)))
           (exit ()
                 (a/terminate))))

(define validation (a/create validation-actor 0 0 0 -1 -1))
(define adapter (a/create data-value-adapter-actor validation))
(define kernel (create-bitonic-sort-kernel-actor N #t adapter))
(define source (a/create int-source-actor kernel))
(a/send source start)
(a/wait)
