#lang racket
(provide t/spawn)
(provide t/join)
(provide t/new-lock)
(provide t/acquire)
(provide t/release)
(provide t/ref)
(provide t/ref-set)
(provide t/deref)
(provide t/display-recorded)

(define thread-return-values (make-hash)) ;; map thread -> value
(define thread-return-values-sem (make-semaphore 1))
(define (thread-set-return-value t v)
  (semaphore-wait thread-return-values-sem)
  ; (fprintf (current-error-port) "setting return value of ~a~n" t)
  (hash-set! thread-return-values t v)
  (semaphore-post thread-return-values-sem))
(define (thread-return-value t)
  (semaphore-wait thread-return-values-sem)
  (when (not (hash-has-key? thread-return-values t))
    (error (format "thread hasn't returned: ~a" t)))
  (let ((v (hash-ref thread-return-values t)))
    (semaphore-post thread-return-values-sem)
    v))

(define thread-names (make-hash (list (cons (current-thread) "main")))) ;; map thread -> name
(define (thread-set-name t v)
  (hash-set! thread-names t v))
(define (thread-name t)
  (when (not (hash-has-key? thread-names t))
    (error (format "thread has no name: ~a" t)))
  (hash-ref thread-names t))

(define (abstract x)
  (cond ((integer? x) 'Num)
        ((real? x) 'Num)
        ((string? x) 'Str)
        ((symbol? x) 'Sym)
;        ((boolean? x) 'Bool)
        ((thread? x) (if (hash-has-key? thread-names x) (string->symbol (thread-name x)) "???"))
        ((procedure? x) x)
        ((list? x) "\"#<list>\"")
        ((pair? x) "\"#<list>\"")
        ((vector? x) "\"#<vector>\"")
        (else x)))

(define recorded-hash (make-hash))
(define record-thread (thread (lambda ()
                                (let loop ()
                                  (let* ((recv (thread-receive))
                                         (prev (if (hash-has-key? recorded-hash (car recv)) (hash-ref recorded-hash (car recv)) (set))))
                                    (hash-set! recorded-hash (car recv) (set-add prev (cdr recv)))
                                    (loop))))))
(define (recorded-values) (hash-keys recorded-hash))
(define (recorded t)
  (list->set (set-map (if (hash-has-key? recorded-hash t) (hash-ref recorded-hash t) (set)) (lambda (x) (map force x)))))
(define (t/display-recorded)
  (sleep 0.5)
  (printf "RESULTS:~n")
  (map (lambda (k)
         (printf "~a~n" (list k (set->list (recorded k)))))
       (recorded-values))
  (void))

(define-syntax (t/spawn stx)
  (with-syntax [(expstr (format "~a" stx))
                (exp (format "~a.~a" (syntax-line (cadr (syntax->list stx))) (+ 2 (syntax-column (cadr (syntax->list stx))))))]
    (syntax-case stx ()
      [(t/spawn e)
       #'(let ((t (thread (lambda ()
                            (thread-set-name (current-thread) exp)
                            (let ((v e))
                              (thread-set-return-value (current-thread) v))))))
           ; (fprintf (current-error-port) "thread ~a creating thread ~a with exp ~a~n" (thread-name (current-thread)) exp expstr)
           (thread-set-name t exp)
           (thread-send record-thread (list (thread-name (current-thread)) 'create exp))
           t)])))
(define (t/join t)
  (thread-send record-thread (list (thread-name (current-thread)) 'join (thread-name t)))
  (thread-wait t)
  (sleep 0.01)
  (thread-return-value t))

(define-syntax-rule (log e ...)
  (begin
    (printf "executing ~a~n" (quote (begin e ...)))
    (let ((res (begin e ...)))
      (printf "done: ~a returns ~a~n" (quote (begin e ...)) res)
      res)))

(define-syntax (t/new-lock stx)
  (with-syntax [(addr (format "~a.~a" (syntax-line stx) (+ 2 (syntax-column stx))))]
    (syntax-case stx ()
      [(t/new-lock) #'(cons (make-semaphore 1) addr)])))
(define (t/acquire lock)
  (thread-send record-thread (list (thread-name (current-thread)) 'acquire (cdr lock)))
  (semaphore-wait (car lock)))
(define (t/release lock)
  (thread-send record-thread (list (thread-name (current-thread)) 'release (cdr lock)))
  (semaphore-post (car lock)))

(define-syntax (t/ref stx)
  (with-syntax [(addr (format "~a.~a" (syntax-line (cadr (syntax->list stx))) (+ 1 (syntax-column (cadr (syntax->list stx))))))]
    (syntax-case stx ()
      [(t/ref val) #'(mcons val addr)])))
(define (t/ref-set var val)
  (thread-send record-thread (list (thread-name (current-thread)) 'write (mcdr var) (delay (abstract val))))
  (set-mcar! var val))
(define (t/deref var)
  (let ((val (mcar var)))
    (thread-send record-thread (list (thread-name (current-thread)) 'read (mcdr var) (delay (abstract val))))
    val))
