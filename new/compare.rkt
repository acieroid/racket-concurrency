#lang racket
(define (read-from-file file)
  (call-with-input-file file
    (lambda (in)
      (define result (make-hash))
      (define (loop)
        (let ((entry (read in)))
          (if (eof-object? entry)
              result
              (let ((key (car entry))
                    (value (cadr entry)))
                (hash-set! result key (set-union (if (hash-has-key? result key) (hash-ref result key) (set)) (list->set value)))
                (loop)))))
      (loop))))
(define (size results)
  (define size 0)
  (for-each (lambda (k)
              (set! size (+ size (set-count (hash-ref results k)))))
            (hash-keys results))
  size)
(define concrete-results (read-from-file (vector-ref (current-command-line-arguments) 0)))
(define abstract-results (read-from-file (vector-ref (current-command-line-arguments) 1)))
(define match #t)
(when (not (equal? concrete-results abstract-results))
  (define keys (hash-keys concrete-results))
  (for-each
   (lambda (k)
     (let ((c (hash-ref concrete-results k (set)))
           (a (hash-ref abstract-results k (set))))
       (when (not (set=? c a))
         (set! match #f)
         ; (printf "mismatch for actor ~a: ~a (conc.) vs. ~a (abs.) ~n" k c a)
         ; (printf "conc - abs = ~a~n" (set-subtract c a))
         (printf "[~a] overapproximates ~a element(s): ~a~n" k (set-count (set-subtract a c)) (set-subtract a c))
         (when (not (set-empty? (set-subtract c a)))
           (printf "UNSOUND on actor ~a ~a~n" k (set-subtract c a))))))
   keys))
(printf "result: ~a, ~a concrete elements~n" match (size concrete-results))
